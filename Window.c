/* Window.c generated by valac 0.56.13, the Vala compiler
 * generated from Window.vala, do not modify */

#include <gtk/gtk.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <gdk/gdk.h>
#include <gio/gio.h>
#include <libnotify/notify.h>
#include <float.h>
#include <math.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define MY_APP_TYPE_WINDOW (my_app_window_get_type ())
#define MY_APP_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_APP_TYPE_WINDOW, MyAppWindow))
#define MY_APP_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MY_APP_TYPE_WINDOW, MyAppWindowClass))
#define MY_APP_IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_APP_TYPE_WINDOW))
#define MY_APP_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_APP_TYPE_WINDOW))
#define MY_APP_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_APP_TYPE_WINDOW, MyAppWindowClass))

typedef struct _MyAppWindow MyAppWindow;
typedef struct _MyAppWindowClass MyAppWindowClass;
typedef struct _MyAppWindowPrivate MyAppWindowPrivate;
enum  {
	MY_APP_WINDOW_0_PROPERTY,
	MY_APP_WINDOW_NUM_PROPERTIES
};
static GParamSpec* my_app_window_properties[MY_APP_WINDOW_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_NOSTALGIA (nostalgia_get_type ())
#define NOSTALGIA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NOSTALGIA, Nostalgia))
#define NOSTALGIA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NOSTALGIA, NostalgiaClass))
#define IS_NOSTALGIA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NOSTALGIA))
#define IS_NOSTALGIA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NOSTALGIA))
#define NOSTALGIA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NOSTALGIA, NostalgiaClass))

typedef struct _Nostalgia Nostalgia;
typedef struct _NostalgiaClass NostalgiaClass;
typedef struct _Block1Data Block1Data;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define MY_APP_TYPE_HEADER_BAR (my_app_header_bar_get_type ())
#define MY_APP_HEADER_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_APP_TYPE_HEADER_BAR, MyAppHeaderBar))
#define MY_APP_HEADER_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MY_APP_TYPE_HEADER_BAR, MyAppHeaderBarClass))
#define MY_APP_IS_HEADER_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_APP_TYPE_HEADER_BAR))
#define MY_APP_IS_HEADER_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_APP_TYPE_HEADER_BAR))
#define MY_APP_HEADER_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_APP_TYPE_HEADER_BAR, MyAppHeaderBarClass))

typedef struct _MyAppHeaderBar MyAppHeaderBar;
typedef struct _MyAppHeaderBarClass MyAppHeaderBarClass;
typedef struct _Block2Data Block2Data;
typedef struct _UpdateLabelFromIstreamData UpdateLabelFromIstreamData;

struct _MyAppWindow {
	GtkApplicationWindow parent_instance;
	MyAppWindowPrivate * priv;
};

struct _MyAppWindowClass {
	GtkApplicationWindowClass parent_class;
};

struct _MyAppWindowPrivate {
	gchar* laoutput;
	gboolean upol;
};

struct _Block1Data {
	int _ref_count_;
	MyAppWindow* self;
	gboolean ssnap;
	GtkStack* actualstack;
	GtkStack* createstack;
	GtkBox* cr1;
	GtkBox* progresscr;
	GdkRGBA black_color;
	GtkFileChooserButton* crloc1;
};

struct _Block2Data {
	int _ref_count_;
	Block1Data * _data1_;
	GSubprocess* ChildProcessBackup;
};

struct _UpdateLabelFromIstreamData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GInputStream* istream;
	GtkTextView* label;
	GtkProgressBar* ProgBar;
	GtkLabel* ProgLabel;
	GDataInputStream* dis;
	GDataInputStream* _tmp0_;
	gchar* line;
	GDataInputStream* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	GtkTextBuffer* _tmp4_;
	GtkTextBuffer* _tmp5_;
	GtkTextBuffer* _tmp6_;
	GtkTextBuffer* _tmp7_;
	GtkTextBuffer* _tmp8_;
	GtkTextBuffer* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	const gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	const gchar* _tmp18_;
	gchar** words;
	const gchar* _tmp19_;
	gchar** _tmp20_;
	gchar** _tmp21_;
	gint words_length1;
	gint _words_size_;
	gchar** _tmp22_;
	gint _tmp22__length1;
	gchar** word_collection;
	gint word_collection_length1;
	gint _word_collection_size_;
	gint word_it;
	const gchar* word;
	const gchar* _tmp23_;
	const gchar* _tmp24_;
	gint _tmp25_;
	gint _tmp26_;
	gchar* word_trimmed;
	const gchar* _tmp27_;
	const gchar* _tmp28_;
	gint _tmp29_;
	gint _tmp30_;
	gchar* _tmp31_;
	gdouble procDone;
	const gchar* _tmp32_;
	const gchar* _tmp33_;
	const gchar* _tmp34_;
	gchar* _tmp35_;
	gchar* _tmp36_;
	gchar* _tmp37_;
	gchar* _tmp38_;
	gchar* _tmp39_;
	gchar* _tmp40_;
	gint _tmp41_;
	gchar* _tmp42_;
	GDataInputStream* _tmp43_;
	gchar* _tmp44_;
	gchar* _tmp45_;
	GError* _inner_error0_;
};

static gint MyAppWindow_private_offset;
static gpointer my_app_window_parent_class = NULL;
VALA_EXTERN gint timer;
gint timer = 0;

VALA_EXTERN GType my_app_window_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MyAppWindow, g_object_unref)
VALA_EXTERN gboolean my_app_window_process_line (MyAppWindow* self,
                                     GIOChannel* channel,
                                     GIOCondition condition,
                                     const gchar* stream_name,
                                     gchar** x,
                                     gboolean* y);
VALA_EXTERN GType nostalgia_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Nostalgia, g_object_unref)
VALA_EXTERN MyAppWindow* my_app_window_new (Nostalgia* application);
VALA_EXTERN MyAppWindow* my_app_window_construct (GType object_type,
                                      Nostalgia* application);
static GObject * my_app_window_constructor (GType type,
                                     guint n_construct_properties,
                                     GObjectConstructParam * construct_properties);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void _my_app_window___lambda4_ (Block1Data* _data1_);
VALA_EXTERN GType my_app_header_bar_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MyAppHeaderBar, g_object_unref)
VALA_EXTERN MyAppHeaderBar* my_app_header_bar_new (GtkStack* stack);
VALA_EXTERN MyAppHeaderBar* my_app_header_bar_construct (GType object_type,
                                             GtkStack* stack);
static void __my_app_window___lambda4__gtk_button_clicked (GtkButton* _sender,
                                                    gpointer self);
static void _my_app_window___lambda5_ (Block1Data* _data1_);
static void __my_app_window___lambda5__gtk_button_clicked (GtkButton* _sender,
                                                    gpointer self);
static void _my_app_window___lambda6_ (Block1Data* _data1_);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static void ____lambda7_ (Block2Data* _data2_,
                   GObject* obj,
                   GAsyncResult* res);
static void _____lambda7__gasync_ready_callback (GObject* source_object,
                                          GAsyncResult* res,
                                          gpointer self);
VALA_EXTERN void update_label_from_istream (GInputStream* istream,
                                GtkTextView* label,
                                GtkProgressBar* ProgBar,
                                GtkLabel* ProgLabel,
                                GAsyncReadyCallback _callback_,
                                gpointer _user_data_);
VALA_EXTERN void update_label_from_istream_finish (GAsyncResult* _res_);
static void __my_app_window___lambda6__gtk_button_clicked (GtkButton* _sender,
                                                    gpointer self);
static void my_app_window_finalize (GObject * obj);
static GType my_app_window_get_type_once (void);
static void update_label_from_istream_data_free (gpointer _data);
static gboolean update_label_from_istream_co (UpdateLabelFromIstreamData* _data_);
static void update_label_from_istream_ready (GObject* source_object,
                                      GAsyncResult* _res_,
                                      gpointer _user_data_);
VALA_EXTERN gint StrToInt (const gchar* str);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static gssize _vala_array_length (gpointer array);

static inline gpointer
my_app_window_get_instance_private (MyAppWindow* self)
{
	return G_STRUCT_MEMBER_P (self, MyAppWindow_private_offset);
}

gboolean
my_app_window_process_line (MyAppWindow* self,
                            GIOChannel* channel,
                            GIOCondition condition,
                            const gchar* stream_name,
                            gchar** x,
                            gboolean* y)
{
	gchar* _vala_x = NULL;
	gboolean _vala_y = FALSE;
	GError* _inner_error0_ = NULL;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (channel != NULL, FALSE);
	g_return_val_if_fail (stream_name != NULL, FALSE);
	if (condition == G_IO_HUP) {
		g_print ("%s: The fd has been closed.\n", stream_name);
		result = FALSE;
		if (x) {
			*x = _vala_x;
		} else {
			_g_free0 (_vala_x);
		}
		if (y) {
			*y = _vala_y;
		}
		return result;
	}
	{
		gchar* line = NULL;
		gchar* _tmp0_ = NULL;
		const gchar* _tmp2_;
		const gchar* _tmp3_;
		gchar* _tmp4_;
		g_io_channel_read_line (channel, &_tmp0_, NULL, NULL, &_inner_error0_);
		_g_free0 (line);
		line = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			gboolean _tmp1_ = FALSE;
			_g_free0 (line);
			if (_inner_error0_->domain == G_IO_CHANNEL_ERROR) {
				goto __catch0_g_io_channel_error;
			}
			if (_inner_error0_->domain == G_CONVERT_ERROR) {
				goto __catch0_g_convert_error;
			}
			_g_free0 (_vala_x);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp1_;
		}
		_tmp2_ = line;
		g_print ("%s: %s", stream_name, _tmp2_);
		_tmp3_ = line;
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (_vala_x);
		_vala_x = _tmp4_;
		_vala_y = TRUE;
		_g_free0 (line);
	}
	goto __finally0;
	__catch0_g_io_channel_error:
	{
		GError* e = NULL;
		GError* _tmp5_;
		const gchar* _tmp6_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp5_ = e;
		_tmp6_ = _tmp5_->message;
		g_print ("%s: IOChannelError: %s\n", stream_name, _tmp6_);
		result = FALSE;
		_g_error_free0 (e);
		if (x) {
			*x = _vala_x;
		} else {
			_g_free0 (_vala_x);
		}
		if (y) {
			*y = _vala_y;
		}
		return result;
	}
	goto __finally0;
	__catch0_g_convert_error:
	{
		GError* e = NULL;
		GError* _tmp7_;
		const gchar* _tmp8_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp7_ = e;
		_tmp8_ = _tmp7_->message;
		g_print ("%s: ConvertError: %s\n", stream_name, _tmp8_);
		result = FALSE;
		_g_error_free0 (e);
		if (x) {
			*x = _vala_x;
		} else {
			_g_free0 (_vala_x);
		}
		if (y) {
			*y = _vala_y;
		}
		return result;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gboolean _tmp9_ = FALSE;
		_g_free0 (_vala_x);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp9_;
	}
	result = TRUE;
	if (x) {
		*x = _vala_x;
	} else {
		_g_free0 (_vala_x);
	}
	if (y) {
		*y = _vala_y;
	}
	return result;
}

MyAppWindow*
my_app_window_construct (GType object_type,
                         Nostalgia* application)
{
	MyAppWindow * self = NULL;
	g_return_val_if_fail (application != NULL, NULL);
	self = (MyAppWindow*) g_object_new (object_type, "application", application, NULL);
	return self;
}

MyAppWindow*
my_app_window_new (Nostalgia* application)
{
	return my_app_window_construct (MY_APP_TYPE_WINDOW, application);
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		MyAppWindow* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->crloc1);
		_g_object_unref0 (_data1_->progresscr);
		_g_object_unref0 (_data1_->cr1);
		_g_object_unref0 (_data1_->createstack);
		_g_object_unref0 (_data1_->actualstack);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}

static void
_my_app_window___lambda4_ (Block1Data* _data1_)
{
	MyAppWindow* self;
	GtkStack* _tmp0_;
	GtkBox* _tmp1_;
	GtkStack* _tmp2_;
	GtkStack* _tmp3_;
	GtkStack* _tmp4_;
	GtkBox* _tmp5_;
	MyAppHeaderBar* crtitlebar = NULL;
	GtkStack* _tmp6_;
	MyAppHeaderBar* _tmp7_;
	MyAppHeaderBar* _tmp8_;
	self = _data1_->self;
	_tmp0_ = _data1_->createstack;
	_tmp1_ = _data1_->cr1;
	gtk_stack_set_visible_child (_tmp0_, (GtkWidget*) _tmp1_);
	g_print ("Create Button Pressed \n");
	_tmp2_ = _data1_->actualstack;
	gtk_container_remove ((GtkContainer*) self, (GtkWidget*) _tmp2_);
	_tmp3_ = _data1_->createstack;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp3_);
	_tmp4_ = _data1_->createstack;
	_tmp5_ = _data1_->cr1;
	gtk_stack_set_visible_child (_tmp4_, (GtkWidget*) _tmp5_);
	_tmp6_ = _data1_->createstack;
	_tmp7_ = my_app_header_bar_new (_tmp6_);
	g_object_ref_sink (_tmp7_);
	crtitlebar = _tmp7_;
	_tmp8_ = crtitlebar;
	gtk_window_set_titlebar ((GtkWindow*) self, (GtkWidget*) _tmp8_);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (crtitlebar);
}

static void
__my_app_window___lambda4__gtk_button_clicked (GtkButton* _sender,
                                               gpointer self)
{
	_my_app_window___lambda4_ (self);
}

static void
_my_app_window___lambda5_ (Block1Data* _data1_)
{
	MyAppWindow* self;
	self = _data1_->self;
	if (!_data1_->ssnap) {
		GtkStack* _tmp0_;
		GtkStack* _tmp1_;
		MyAppHeaderBar* hmtitlebar = NULL;
		GtkStack* _tmp2_;
		MyAppHeaderBar* _tmp3_;
		MyAppHeaderBar* _tmp4_;
		gchar* x = NULL;
		g_print ("Menu Button Pressed \n");
		_tmp0_ = _data1_->createstack;
		gtk_container_remove ((GtkContainer*) self, (GtkWidget*) _tmp0_);
		_tmp1_ = _data1_->actualstack;
		gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp1_);
		_tmp2_ = _data1_->actualstack;
		_tmp3_ = my_app_header_bar_new (_tmp2_);
		g_object_ref_sink (_tmp3_);
		hmtitlebar = _tmp3_;
		_tmp4_ = hmtitlebar;
		gtk_window_set_titlebar ((GtkWindow*) self, (GtkWidget*) _tmp4_);
		gtk_widget_show_all ((GtkWidget*) self);
		_g_free0 (x);
		_g_object_unref0 (hmtitlebar);
	}
}

static void
__my_app_window___lambda5__gtk_button_clicked (GtkButton* _sender,
                                               gpointer self)
{
	_my_app_window___lambda5_ (self);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static Block2Data*
block2_data_ref (Block2Data* _data2_)
{
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}

static void
block2_data_unref (void * _userdata_)
{
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		MyAppWindow* self;
		self = _data2_->_data1_->self;
		_g_object_unref0 (_data2_->ChildProcessBackup);
		block1_data_unref (_data2_->_data1_);
		_data2_->_data1_ = NULL;
		g_slice_free (Block2Data, _data2_);
	}
}

static void
____lambda7_ (Block2Data* _data2_,
              GObject* obj,
              GAsyncResult* res)
{
	Block1Data* _data1_;
	MyAppWindow* self;
	GError* _inner_error0_ = NULL;
	_data1_ = _data2_->_data1_;
	self = _data1_->self;
	g_return_if_fail (res != NULL);
	{
		GSubprocess* _tmp0_;
		GtkStack* _tmp1_;
		GtkBox* _tmp2_;
		NotifyNotification* notification = NULL;
		NotifyNotification* _tmp3_;
		NotifyNotification* _tmp4_;
		NotifyNotification* _tmp5_;
		GList* progresscrChildren = NULL;
		GtkBox* _tmp6_;
		GList* _tmp7_;
		GList* _tmp8_;
		_tmp0_ = _data2_->ChildProcessBackup;
		g_subprocess_wait_check_finish (_tmp0_, res, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		g_print ("\n\n-------SUCCESFULL------\n\n");
		_data1_->ssnap = FALSE;
		_tmp1_ = _data1_->createstack;
		_tmp2_ = _data1_->cr1;
		gtk_stack_set_visible_child (_tmp1_, (GtkWidget*) _tmp2_);
		notify_init ("Nostalgia");
		_tmp3_ = notify_notification_new ("Nostalgia", "Your snapshot is ready", "deja-dup");
		notification = _tmp3_;
		_tmp4_ = notification;
		notify_notification_set_timeout (_tmp4_, 0);
		_tmp5_ = notification;
		notify_notification_show (_tmp5_, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (notification);
			goto __catch0_g_error;
		}
		g_print ("\nREMOVING CHILDREN FROM PAGE\n");
		_tmp6_ = _data1_->progresscr;
		_tmp7_ = gtk_container_get_children ((GtkContainer*) _tmp6_);
		progresscrChildren = _tmp7_;
		_tmp8_ = progresscrChildren;
		{
			GList* element_collection = NULL;
			GList* element_it = NULL;
			element_collection = _tmp8_;
			for (element_it = element_collection; element_it != NULL; element_it = element_it->next) {
				GtkWidget* _tmp9_;
				GtkWidget* element = NULL;
				_tmp9_ = _g_object_ref0 ((GtkWidget*) element_it->data);
				element = _tmp9_;
				{
					GtkBox* _tmp10_;
					GtkWidget* _tmp11_;
					_tmp10_ = _data1_->progresscr;
					_tmp11_ = element;
					gtk_container_remove ((GtkContainer*) _tmp10_, _tmp11_);
					_g_object_unref0 (element);
				}
			}
		}
		(progresscrChildren == NULL) ? NULL : (progresscrChildren = (g_list_free (progresscrChildren), NULL));
		_g_object_unref0 (notification);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* err = NULL;
		GError* _tmp12_;
		const gchar* _tmp13_;
		GtkStack* _tmp14_;
		GtkBox* _tmp15_;
		GtkDialog* ibl = NULL;
		GtkDialog* _tmp16_;
		GtkBox* iblca = NULL;
		GtkDialog* _tmp17_;
		GtkBox* _tmp18_;
		GtkBox* _tmp19_;
		GtkBox* _tmp20_;
		GtkLabel* _tmp21_;
		GtkLabel* _tmp22_;
		GtkBox* _tmp23_;
		GtkLabel* _tmp24_;
		GtkLabel* _tmp25_;
		GtkBox* _tmp26_;
		GtkLabel* _tmp27_;
		GtkLabel* _tmp28_;
		GtkDialog* _tmp29_;
		GList* progresscrChildren = NULL;
		GtkBox* _tmp30_;
		GList* _tmp31_;
		GList* _tmp32_;
		err = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp12_ = err;
		_tmp13_ = _tmp12_->message;
		g_print ("\n\n------ERROR!!!------\n%s\n\n", _tmp13_);
		_tmp14_ = _data1_->createstack;
		_tmp15_ = _data1_->cr1;
		gtk_stack_set_visible_child (_tmp14_, (GtkWidget*) _tmp15_);
		_tmp16_ = (GtkDialog*) gtk_dialog_new_with_buttons ("Error Spawning Process", (GtkWindow*) self, (GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT) | GTK_DIALOG_USE_HEADER_BAR, NULL, NULL);
		g_object_ref_sink (_tmp16_);
		ibl = _tmp16_;
		_tmp17_ = ibl;
		_tmp18_ = gtk_dialog_get_content_area (_tmp17_);
		_tmp19_ = _g_object_ref0 (_tmp18_);
		iblca = _tmp19_;
		_tmp20_ = iblca;
		_tmp21_ = (GtkLabel*) gtk_label_new ("\n\n							");
		g_object_ref_sink (_tmp21_);
		_tmp22_ = _tmp21_;
		gtk_container_add ((GtkContainer*) _tmp20_, (GtkWidget*) _tmp22_);
		_g_object_unref0 (_tmp22_);
		_tmp23_ = iblca;
		_tmp24_ = (GtkLabel*) gtk_label_new ("	Make sure /usr/bin/rsync is installed, up to date and that you have r" \
"oot privileges and have inputed your correct user password	");
		g_object_ref_sink (_tmp24_);
		_tmp25_ = _tmp24_;
		gtk_container_add ((GtkContainer*) _tmp23_, (GtkWidget*) _tmp25_);
		_g_object_unref0 (_tmp25_);
		_tmp26_ = iblca;
		_tmp27_ = (GtkLabel*) gtk_label_new ("\n							\n							");
		g_object_ref_sink (_tmp27_);
		_tmp28_ = _tmp27_;
		gtk_container_add ((GtkContainer*) _tmp26_, (GtkWidget*) _tmp28_);
		_g_object_unref0 (_tmp28_);
		_tmp29_ = ibl;
		gtk_widget_show_all ((GtkWidget*) _tmp29_);
		g_print ("\nREMOVING CHILDREN FROM PAGE\n");
		_tmp30_ = _data1_->progresscr;
		_tmp31_ = gtk_container_get_children ((GtkContainer*) _tmp30_);
		progresscrChildren = _tmp31_;
		_tmp32_ = progresscrChildren;
		{
			GList* element_collection = NULL;
			GList* element_it = NULL;
			element_collection = _tmp32_;
			for (element_it = element_collection; element_it != NULL; element_it = element_it->next) {
				GtkWidget* _tmp33_;
				GtkWidget* element = NULL;
				_tmp33_ = _g_object_ref0 ((GtkWidget*) element_it->data);
				element = _tmp33_;
				{
					GtkBox* _tmp34_;
					GtkWidget* _tmp35_;
					_tmp34_ = _data1_->progresscr;
					_tmp35_ = element;
					gtk_container_remove ((GtkContainer*) _tmp34_, _tmp35_);
					_g_object_unref0 (element);
				}
			}
		}
		_data1_->ssnap = FALSE;
		(progresscrChildren == NULL) ? NULL : (progresscrChildren = (g_list_free (progresscrChildren), NULL));
		_g_object_unref0 (iblca);
		_g_object_unref0 (ibl);
		_g_error_free0 (err);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static void
_____lambda7__gasync_ready_callback (GObject* source_object,
                                     GAsyncResult* res,
                                     gpointer self)
{
	____lambda7_ (self, source_object, res);
	block2_data_unref (self);
}

static void
_my_app_window___lambda6_ (Block1Data* _data1_)
{
	MyAppWindow* self;
	GError* _inner_error0_ = NULL;
	self = _data1_->self;
	if (!_data1_->ssnap) {
		GtkFileChooserButton* _tmp0_;
		gchar* _tmp1_;
		gchar* _tmp2_;
		gchar* loc = NULL;
		GtkFileChooserButton* _tmp3_;
		gchar* _tmp4_;
		GtkFileChooserButton* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		GtkFileChooserButton* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		gboolean _tmp11_;
		_tmp0_ = _data1_->crloc1;
		_tmp1_ = gtk_file_chooser_get_filename ((GtkFileChooser*) _tmp0_);
		_tmp2_ = _tmp1_;
		g_print ("%s", _tmp2_);
		_g_free0 (_tmp2_);
		_tmp3_ = _data1_->crloc1;
		_tmp4_ = gtk_file_chooser_get_filename ((GtkFileChooser*) _tmp3_);
		loc = _tmp4_;
		g_print ("\n");
		_tmp5_ = _data1_->crloc1;
		_tmp6_ = gtk_file_chooser_get_filename ((GtkFileChooser*) _tmp5_);
		_tmp7_ = _tmp6_;
		g_print ("%s", _tmp7_);
		_g_free0 (_tmp7_);
		_tmp8_ = _data1_->crloc1;
		_tmp9_ = gtk_file_chooser_get_filename ((GtkFileChooser*) _tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = _tmp10_ == NULL;
		_g_free0 (_tmp10_);
		if (_tmp11_) {
			GtkDialog* ibl = NULL;
			GtkDialog* _tmp12_;
			GtkBox* iblca = NULL;
			GtkDialog* _tmp13_;
			GtkBox* _tmp14_;
			GtkBox* _tmp15_;
			GtkBox* _tmp16_;
			GtkLabel* _tmp17_;
			GtkLabel* _tmp18_;
			GtkBox* _tmp19_;
			GtkLabel* _tmp20_;
			GtkLabel* _tmp21_;
			GtkBox* _tmp22_;
			GtkLabel* _tmp23_;
			GtkLabel* _tmp24_;
			GtkDialog* _tmp25_;
			_tmp12_ = (GtkDialog*) gtk_dialog_new_with_buttons ("Invaild backup location", (GtkWindow*) self, (GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT) | GTK_DIALOG_USE_HEADER_BAR, NULL, NULL);
			g_object_ref_sink (_tmp12_);
			ibl = _tmp12_;
			_tmp13_ = ibl;
			_tmp14_ = gtk_dialog_get_content_area (_tmp13_);
			_tmp15_ = _g_object_ref0 (_tmp14_);
			iblca = _tmp15_;
			_tmp16_ = iblca;
			_tmp17_ = (GtkLabel*) gtk_label_new ("\n\n					");
			g_object_ref_sink (_tmp17_);
			_tmp18_ = _tmp17_;
			gtk_container_add ((GtkContainer*) _tmp16_, (GtkWidget*) _tmp18_);
			_g_object_unref0 (_tmp18_);
			_tmp19_ = iblca;
			_tmp20_ = (GtkLabel*) gtk_label_new ("	Make sure the folder you picked is mounted and exists	");
			g_object_ref_sink (_tmp20_);
			_tmp21_ = _tmp20_;
			gtk_container_add ((GtkContainer*) _tmp19_, (GtkWidget*) _tmp21_);
			_g_object_unref0 (_tmp21_);
			_tmp22_ = iblca;
			_tmp23_ = (GtkLabel*) gtk_label_new ("\n					\n					");
			g_object_ref_sink (_tmp23_);
			_tmp24_ = _tmp23_;
			gtk_container_add ((GtkContainer*) _tmp22_, (GtkWidget*) _tmp24_);
			_g_object_unref0 (_tmp24_);
			_tmp25_ = ibl;
			gtk_widget_show_all ((GtkWidget*) _tmp25_);
			_g_object_unref0 (iblca);
			_g_object_unref0 (ibl);
		} else {
			Block2Data* _data2_;
			GtkStack* _tmp26_;
			GtkBox* _tmp27_;
			gchar* isfile = NULL;
			GtkFileChooserButton* _tmp28_;
			gchar* _tmp29_;
			gchar* _tmp30_;
			gchar* _tmp31_;
			gchar* _tmp32_;
			gchar* _tmp33_;
			gchar* _tmp34_;
			gchar* _tmp35_ = NULL;
			gchar* isft = NULL;
			GtkFileChooserButton* _tmp36_;
			gchar* _tmp37_;
			gchar* _tmp38_;
			gchar* _tmp39_;
			gchar* _tmp40_;
			const gchar* _tmp41_;
			const gchar* _tmp42_;
			GtkTextView* lbl = NULL;
			GtkTextView* _tmp43_;
			GtkTextView* _tmp44_;
			GtkTextView* _tmp45_;
			GdkRGBA _tmp46_;
			GtkScrolledWindow* lblScroll = NULL;
			GtkScrolledWindow* _tmp47_;
			GtkScrolledWindow* _tmp48_;
			GtkTextView* _tmp49_;
			GtkScrolledWindow* _tmp50_;
			GtkBox* _tmp51_;
			GtkScrolledWindow* _tmp52_;
			GtkProgressBar* ProgBar = NULL;
			GtkProgressBar* _tmp53_;
			GtkBox* _tmp54_;
			GtkProgressBar* _tmp55_;
			GtkLabel* ProgLabel = NULL;
			GtkLabel* _tmp56_;
			GtkBox* _tmp57_;
			GtkLabel* _tmp58_;
			const gchar* _tmp59_;
			const gchar* _tmp60_;
			gchar** spawn_env1 = NULL;
			gchar** _tmp68_;
			gchar** _tmp69_;
			gint spawn_env1_length1;
			gint _spawn_env1_size_;
			GPid rpid = 0;
			gint otcr = 0;
			gint dum = 0;
			gboolean lop = FALSE;
			gchar** backup_command = NULL;
			gchar* _tmp70_;
			gchar* _tmp71_;
			gchar* _tmp72_;
			gchar* _tmp73_;
			gchar* _tmp74_;
			gchar* _tmp75_;
			gchar* _tmp76_;
			gchar* _tmp77_;
			gchar** _tmp78_;
			gint backup_command_length1;
			gint _backup_command_size_;
			gchar** _tmp79_;
			gint _tmp79__length1;
			GSubprocess* _tmp80_;
			GSubprocess* _tmp81_;
			GInputStream* OutputPipeBackup = NULL;
			GSubprocess* _tmp82_;
			GInputStream* _tmp83_;
			GInputStream* _tmp84_;
			GInputStream* _tmp85_;
			GtkTextView* _tmp86_;
			GtkProgressBar* _tmp87_;
			GtkLabel* _tmp88_;
			_data2_ = g_slice_new0 (Block2Data);
			_data2_->_ref_count_ = 1;
			_data2_->_data1_ = block1_data_ref (_data1_);
			_data1_->ssnap = TRUE;
			_tmp26_ = _data1_->createstack;
			_tmp27_ = _data1_->progresscr;
			gtk_stack_set_visible_child (_tmp26_, (GtkWidget*) _tmp27_);
			_tmp28_ = _data1_->crloc1;
			_tmp29_ = gtk_file_chooser_get_filename ((GtkFileChooser*) _tmp28_);
			_tmp30_ = _tmp29_;
			_tmp31_ = g_strconcat ("file ", _tmp30_, NULL);
			_tmp32_ = _tmp31_;
			_tmp33_ = g_strconcat (_tmp32_, "/nostalgia.file", NULL);
			_tmp34_ = _tmp33_;
			g_spawn_command_line_sync (_tmp34_, &_tmp35_, NULL, NULL, &_inner_error0_);
			_g_free0 (isfile);
			isfile = _tmp35_;
			_g_free0 (_tmp34_);
			_g_free0 (_tmp32_);
			_g_free0 (_tmp30_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_free0 (isfile);
				block2_data_unref (_data2_);
				_data2_ = NULL;
				_g_free0 (loc);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
			_tmp36_ = _data1_->crloc1;
			_tmp37_ = gtk_file_chooser_get_filename ((GtkFileChooser*) _tmp36_);
			_tmp38_ = _tmp37_;
			_tmp39_ = g_strconcat (_tmp38_, "/nostalgia.file: empty ", NULL);
			_tmp40_ = _tmp39_;
			_g_free0 (_tmp38_);
			isft = _tmp40_;
			_tmp41_ = isfile;
			g_print ("%s", _tmp41_);
			_tmp42_ = isft;
			g_print ("%s", _tmp42_);
			_tmp43_ = (GtkTextView*) gtk_text_view_new ();
			g_object_ref_sink (_tmp43_);
			lbl = _tmp43_;
			_tmp44_ = lbl;
			gtk_text_view_set_wrap_mode (_tmp44_, GTK_WRAP_WORD);
			_tmp45_ = lbl;
			_tmp46_ = _data1_->black_color;
			gtk_widget_override_background_color ((GtkWidget*) _tmp45_, GTK_STATE_FLAG_NORMAL, &_tmp46_);
			_tmp47_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
			g_object_ref_sink (_tmp47_);
			lblScroll = _tmp47_;
			_tmp48_ = lblScroll;
			_tmp49_ = lbl;
			gtk_container_add ((GtkContainer*) _tmp48_, (GtkWidget*) _tmp49_);
			_tmp50_ = lblScroll;
			gtk_scrolled_window_set_max_content_height (_tmp50_, 600);
			_tmp51_ = _data1_->progresscr;
			_tmp52_ = lblScroll;
			gtk_box_pack_start (_tmp51_, (GtkWidget*) _tmp52_, TRUE, TRUE, (guint) 0);
			_tmp53_ = (GtkProgressBar*) gtk_progress_bar_new ();
			g_object_ref_sink (_tmp53_);
			ProgBar = _tmp53_;
			_tmp54_ = _data1_->progresscr;
			_tmp55_ = ProgBar;
			gtk_box_pack_end (_tmp54_, (GtkWidget*) _tmp55_, TRUE, TRUE, (guint) 0);
			_tmp56_ = (GtkLabel*) gtk_label_new ("Nostalgia Progress: 0%");
			g_object_ref_sink (_tmp56_);
			ProgLabel = _tmp56_;
			_tmp57_ = _data1_->progresscr;
			_tmp58_ = ProgLabel;
			gtk_box_pack_end (_tmp57_, (GtkWidget*) _tmp58_, TRUE, TRUE, (guint) 0);
			_tmp59_ = isfile;
			_tmp60_ = isft;
			if (g_utf8_strlen (_tmp59_, (gssize) -1) != g_utf8_strlen (_tmp60_, (gssize) -1)) {
				gchar* testx = NULL;
				GtkBox* _tmp61_;
				const gchar* _tmp62_;
				GtkLabel* _tmp63_;
				GtkLabel* _tmp64_;
				GtkBox* _tmp65_;
				GtkLabel* _tmp66_;
				GtkLabel* _tmp67_;
				g_print ("\n root backup \n");
				_tmp61_ = _data1_->progresscr;
				_tmp62_ = testx;
				_tmp63_ = (GtkLabel*) gtk_label_new (_tmp62_);
				g_object_ref_sink (_tmp63_);
				_tmp64_ = _tmp63_;
				gtk_box_pack_start (_tmp61_, (GtkWidget*) _tmp64_, TRUE, TRUE, (guint) 0);
				_g_object_unref0 (_tmp64_);
				_tmp65_ = _data1_->progresscr;
				_tmp66_ = (GtkLabel*) gtk_label_new ("This seems to be your first nostalgia backup on this harddrive, so it " \
"will take a while");
				g_object_ref_sink (_tmp66_);
				_tmp67_ = _tmp66_;
				gtk_box_pack_start (_tmp65_, (GtkWidget*) _tmp67_, FALSE, FALSE, (guint) 10);
				_g_object_unref0 (_tmp67_);
				gtk_widget_show_all ((GtkWidget*) self);
				_g_free0 (testx);
			}
			_tmp69_ = _tmp68_ = g_get_environ ();
			spawn_env1 = _tmp69_;
			spawn_env1_length1 = _vala_array_length (_tmp68_);
			_spawn_env1_size_ = spawn_env1_length1;
			lop = TRUE;
			_tmp70_ = g_strdup ("/usr/bin/pkexec");
			_tmp71_ = g_strdup ("/usr/bin/rsync");
			_tmp72_ = g_strdup ("-ahv");
			_tmp73_ = g_strdup ("/home/ioachim/Music");
			_tmp74_ = g_strdup ("/home/ioachim/Music2");
			_tmp75_ = g_strdup ("--no-i-r");
			_tmp76_ = g_strdup ("--info=progress2");
			_tmp77_ = g_strdup ("--fsync");
			_tmp78_ = g_new0 (gchar*, 9 + 1);
			_tmp78_[0] = _tmp70_;
			_tmp78_[1] = _tmp71_;
			_tmp78_[2] = _tmp72_;
			_tmp78_[3] = _tmp73_;
			_tmp78_[4] = _tmp74_;
			_tmp78_[5] = _tmp75_;
			_tmp78_[6] = _tmp76_;
			_tmp78_[7] = _tmp77_;
			_tmp78_[8] = NULL;
			backup_command = _tmp78_;
			backup_command_length1 = 9;
			_backup_command_size_ = backup_command_length1;
			_tmp79_ = backup_command;
			_tmp79__length1 = backup_command_length1;
			_tmp80_ = g_subprocess_newv (_tmp79_, G_SUBPROCESS_FLAGS_STDOUT_PIPE, &_inner_error0_);
			_data2_->ChildProcessBackup = _tmp80_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				backup_command = (_vala_array_free (backup_command, backup_command_length1, (GDestroyNotify) g_free), NULL);
				spawn_env1 = (_vala_array_free (spawn_env1, spawn_env1_length1, (GDestroyNotify) g_free), NULL);
				_g_object_unref0 (ProgLabel);
				_g_object_unref0 (ProgBar);
				_g_object_unref0 (lblScroll);
				_g_object_unref0 (lbl);
				_g_free0 (isft);
				_g_free0 (isfile);
				block2_data_unref (_data2_);
				_data2_ = NULL;
				_g_free0 (loc);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
			_tmp81_ = _data2_->ChildProcessBackup;
			g_subprocess_wait_check_async (_tmp81_, NULL, _____lambda7__gasync_ready_callback, block2_data_ref (_data2_));
			_tmp82_ = _data2_->ChildProcessBackup;
			_tmp83_ = g_subprocess_get_stdout_pipe (_tmp82_);
			_tmp84_ = _g_object_ref0 (_tmp83_);
			OutputPipeBackup = _tmp84_;
			_tmp85_ = OutputPipeBackup;
			_tmp86_ = lbl;
			_tmp87_ = ProgBar;
			_tmp88_ = ProgLabel;
			update_label_from_istream (_tmp85_, _tmp86_, _tmp87_, _tmp88_, NULL, NULL);
			_g_object_unref0 (OutputPipeBackup);
			backup_command = (_vala_array_free (backup_command, backup_command_length1, (GDestroyNotify) g_free), NULL);
			spawn_env1 = (_vala_array_free (spawn_env1, spawn_env1_length1, (GDestroyNotify) g_free), NULL);
			_g_object_unref0 (ProgLabel);
			_g_object_unref0 (ProgBar);
			_g_object_unref0 (lblScroll);
			_g_object_unref0 (lbl);
			_g_free0 (isft);
			_g_free0 (isfile);
			block2_data_unref (_data2_);
			_data2_ = NULL;
		}
		_g_free0 (loc);
	}
}

static void
__my_app_window___lambda6__gtk_button_clicked (GtkButton* _sender,
                                               gpointer self)
{
	_my_app_window___lambda6_ (self);
}

static GObject *
my_app_window_constructor (GType type,
                           guint n_construct_properties,
                           GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	MyAppWindow * self;
	Block1Data* _data1_;
	GtkStack* _tmp0_;
	GtkStack* _tmp1_;
	GtkStack* _tmp2_;
	GtkStack* _tmp3_;
	GtkBox* memc = NULL;
	GtkBox* _tmp4_;
	GtkBox* memr = NULL;
	GtkBox* _tmp5_;
	GtkBox* _tmp6_;
	GtkBox* _tmp7_;
	GtkStack* _tmp8_;
	GtkBox* _tmp9_;
	GtkStack* _tmp10_;
	GtkBox* _tmp11_;
	GtkStack* _tmp12_;
	GtkBox* _tmp13_;
	GtkStack* _tmp14_;
	GtkBox* _tmp15_;
	GtkStack* _tmp16_;
	GtkStack* _tmp17_;
	GtkStack* _tmp18_;
	GtkStack* _tmp19_;
	GtkLabel* label1 = NULL;
	GtkLabel* _tmp20_;
	GtkLabel* _tmp21_;
	GtkBox* _tmp22_;
	GtkLabel* _tmp23_;
	GtkBox* _tmp24_;
	GtkLabel* _tmp25_;
	GtkLabel* _tmp26_;
	GtkButton* button1 = NULL;
	GtkButton* _tmp27_;
	GdkRGBA blue_color = {0};
	GdkRGBA green_color = {0};
	GtkButton* _tmp28_;
	GdkRGBA _tmp29_;
	GtkGrid* gridfb = NULL;
	GtkGrid* _tmp30_;
	GtkGrid* _tmp31_;
	GtkButton* _tmp32_;
	GtkButton* _tmp33_;
	GtkGrid* _tmp34_;
	GtkLabel* _tmp35_;
	GtkLabel* _tmp36_;
	GtkGrid* _tmp37_;
	GtkLabel* _tmp38_;
	GtkLabel* _tmp39_;
	GtkGrid* _tmp40_;
	GtkGrid* _tmp41_;
	GtkBox* _tmp42_;
	GtkGrid* _tmp43_;
	GtkLabel* label1r = NULL;
	GtkLabel* _tmp44_;
	GtkLabel* _tmp45_;
	GtkBox* _tmp46_;
	GtkLabel* _tmp47_;
	GtkBox* _tmp48_;
	GtkLabel* _tmp49_;
	GtkLabel* _tmp50_;
	GtkButton* button1r = NULL;
	GtkButton* _tmp51_;
	GtkButton* _tmp52_;
	GdkRGBA _tmp53_;
	GtkGrid* gridfbr = NULL;
	GtkGrid* _tmp54_;
	GtkGrid* _tmp55_;
	GtkButton* _tmp56_;
	GtkGrid* _tmp57_;
	GtkLabel* _tmp58_;
	GtkLabel* _tmp59_;
	GtkGrid* _tmp60_;
	GtkLabel* _tmp61_;
	GtkLabel* _tmp62_;
	GtkGrid* _tmp63_;
	GtkGrid* _tmp64_;
	GtkBox* _tmp65_;
	GtkGrid* _tmp66_;
	GtkBox* _tmp67_;
	GtkLabel* _tmp68_;
	GtkLabel* _tmp69_;
	GtkBox* cr11 = NULL;
	GtkBox* _tmp70_;
	GtkBox* _tmp71_;
	GtkLabel* _tmp72_;
	GtkLabel* _tmp73_;
	GtkLabel* cr1label = NULL;
	GtkLabel* _tmp74_;
	GtkLabel* _tmp75_;
	GtkBox* _tmp76_;
	GtkLabel* _tmp77_;
	GtkFileChooserButton* _tmp78_;
	GtkBox* _tmp79_;
	GtkFileChooserButton* _tmp80_;
	GtkBox* _tmp81_;
	GtkLabel* _tmp82_;
	GtkLabel* _tmp83_;
	GtkBox* _tmp84_;
	GtkBox* _tmp85_;
	GtkBox* _tmp86_;
	GtkLabel* _tmp87_;
	GtkLabel* _tmp88_;
	GtkBox* cr12 = NULL;
	GtkBox* _tmp89_;
	GtkButton* crbackbutton = NULL;
	GtkButton* _tmp90_;
	GtkButton* _tmp91_;
	GtkBox* _tmp92_;
	GtkButton* _tmp93_;
	GtkBox* cr15 = NULL;
	GtkBox* _tmp94_;
	GtkScrolledWindow* ExcludePanel = NULL;
	GtkScrolledWindow* _tmp95_;
	GtkLabel* ExcludeListLabel = NULL;
	GtkLabel* _tmp96_;
	GtkTextView* ExcludeList = NULL;
	GtkTextView* _tmp97_;
	GtkTextView* _tmp98_;
	GtkTextView* _tmp99_;
	GtkTextView* _tmp100_;
	GdkRGBA _tmp101_;
	GtkScrolledWindow* _tmp102_;
	GtkScrolledWindow* _tmp103_;
	GtkScrolledWindow* _tmp104_;
	GtkTextView* _tmp105_;
	GtkBox* _tmp106_;
	GtkLabel* _tmp107_;
	GtkBox* cr151 = NULL;
	GtkBox* _tmp108_;
	GtkBox* _tmp109_;
	GtkLabel* _tmp110_;
	GtkLabel* _tmp111_;
	GtkBox* _tmp112_;
	GtkScrolledWindow* _tmp113_;
	GtkBox* _tmp114_;
	GtkLabel* _tmp115_;
	GtkLabel* _tmp116_;
	GtkBox* _tmp117_;
	GtkBox* _tmp118_;
	GtkBox* _tmp119_;
	GtkBox* _tmp120_;
	GtkButton* finbutcr = NULL;
	GtkButton* _tmp121_;
	GtkButton* _tmp122_;
	GdkRGBA _tmp123_;
	GtkBox* _tmp124_;
	GtkButton* _tmp125_;
	GtkButton* _tmp126_;
	GtkBox* _tmp127_;
	GtkBox* _tmp128_;
	GtkStack* _tmp129_;
	MyAppHeaderBar* headerbar = NULL;
	GtkStack* _tmp130_;
	MyAppHeaderBar* _tmp131_;
	MyAppHeaderBar* _tmp132_;
	parent_class = G_OBJECT_CLASS (my_app_window_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MY_APP_TYPE_WINDOW, MyAppWindow);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_data1_->ssnap = FALSE;
	_tmp0_ = (GtkStack*) gtk_stack_new ();
	g_object_ref_sink (_tmp0_);
	_data1_->actualstack = _tmp0_;
	_tmp1_ = _data1_->actualstack;
	g_object_set ((GtkWidget*) _tmp1_, "expand", TRUE, NULL);
	_tmp2_ = (GtkStack*) gtk_stack_new ();
	g_object_ref_sink (_tmp2_);
	_data1_->createstack = _tmp2_;
	_tmp3_ = _data1_->createstack;
	g_object_set ((GtkWidget*) _tmp3_, "expand", TRUE, NULL);
	_tmp4_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp4_);
	memc = _tmp4_;
	_tmp5_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp5_);
	memr = _tmp5_;
	_tmp6_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp6_);
	_data1_->cr1 = _tmp6_;
	_tmp7_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp7_);
	_data1_->progresscr = _tmp7_;
	_tmp8_ = _data1_->actualstack;
	_tmp9_ = memc;
	gtk_stack_add_titled (_tmp8_, (GtkWidget*) _tmp9_, "memc", "Create");
	_tmp10_ = _data1_->actualstack;
	_tmp11_ = memr;
	gtk_stack_add_titled (_tmp10_, (GtkWidget*) _tmp11_, "memr", "Restore");
	_tmp12_ = _data1_->createstack;
	_tmp13_ = _data1_->cr1;
	gtk_stack_add_titled (_tmp12_, (GtkWidget*) _tmp13_, "cr1", "Backup Options");
	_tmp14_ = _data1_->createstack;
	_tmp15_ = _data1_->progresscr;
	gtk_stack_add_titled (_tmp14_, (GtkWidget*) _tmp15_, "progresscr", "Snapshot Progress");
	_tmp16_ = _data1_->actualstack;
	gtk_stack_set_transition_type (_tmp16_, GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN);
	_tmp17_ = _data1_->actualstack;
	gtk_stack_set_transition_duration (_tmp17_, (guint) 750);
	_tmp18_ = _data1_->createstack;
	gtk_stack_set_transition_type (_tmp18_, GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN);
	_tmp19_ = _data1_->createstack;
	gtk_stack_set_transition_duration (_tmp19_, (guint) 750);
	_tmp20_ = (GtkLabel*) gtk_label_new ("<span size='xx-large' weight='bold'>Back up all your files and memorie" \
"s,\n" \
"For when you need them the most</span>");
	g_object_ref_sink (_tmp20_);
	label1 = _tmp20_;
	_tmp21_ = label1;
	gtk_label_set_use_markup (_tmp21_, TRUE);
	_tmp22_ = memc;
	_tmp23_ = label1;
	gtk_box_pack_start (_tmp22_, (GtkWidget*) _tmp23_, TRUE, TRUE, (guint) 50);
	_tmp24_ = memc;
	_tmp25_ = (GtkLabel*) gtk_label_new ("Nostalgia makes incremental snapshots, that means:\n" \
"✔ Only the first snapshot contains the full file system\n" \
"✔ All snapshots after the first only document changes\n" \
"✔ It takes up significantly less space compared to full system snapsho" \
"ts\n" \
"✔ You can hold lots of backups on a drive");
	g_object_ref_sink (_tmp25_);
	_tmp26_ = _tmp25_;
	gtk_box_pack_start (_tmp24_, (GtkWidget*) _tmp26_, TRUE, FALSE, (guint) 0);
	_g_object_unref0 (_tmp26_);
	_tmp27_ = (GtkButton*) gtk_button_new_with_label ("Create memory");
	g_object_ref_sink (_tmp27_);
	button1 = _tmp27_;
	memset (&blue_color, 0, sizeof (GdkRGBA));
	gdk_rgba_parse (&blue_color, "#0860F2");
	memset (&green_color, 0, sizeof (GdkRGBA));
	gdk_rgba_parse (&green_color, "#59C837");
	memset (&_data1_->black_color, 0, sizeof (GdkRGBA));
	gdk_rgba_parse (&_data1_->black_color, "#15161E");
	_tmp28_ = button1;
	_tmp29_ = green_color;
	gtk_widget_override_background_color ((GtkWidget*) _tmp28_, GTK_STATE_FLAG_NORMAL, &_tmp29_);
	_tmp30_ = (GtkGrid*) gtk_grid_new ();
	g_object_ref_sink (_tmp30_);
	gridfb = _tmp30_;
	_tmp31_ = gridfb;
	_tmp32_ = button1;
	gtk_grid_attach (_tmp31_, (GtkWidget*) _tmp32_, 1, 1, 1, 1);
	_tmp33_ = button1;
	g_signal_connect_data (_tmp33_, "clicked", (GCallback) __my_app_window___lambda4__gtk_button_clicked, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp34_ = gridfb;
	_tmp35_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp35_);
	_tmp36_ = _tmp35_;
	gtk_grid_attach (_tmp34_, (GtkWidget*) _tmp36_, 2, 1, 1, 1);
	_g_object_unref0 (_tmp36_);
	_tmp37_ = gridfb;
	_tmp38_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp38_);
	_tmp39_ = _tmp38_;
	gtk_grid_attach (_tmp37_, (GtkWidget*) _tmp39_, 0, 1, 1, 1);
	_g_object_unref0 (_tmp39_);
	_tmp40_ = gridfb;
	gtk_grid_set_column_homogeneous (_tmp40_, TRUE);
	_tmp41_ = gridfb;
	gtk_grid_set_row_homogeneous (_tmp41_, TRUE);
	_tmp42_ = memc;
	_tmp43_ = gridfb;
	gtk_box_pack_start (_tmp42_, (GtkWidget*) _tmp43_, TRUE, TRUE, (guint) 60);
	_tmp44_ = (GtkLabel*) gtk_label_new ("<span size='xx-large' weight='bold'>For when the worst happens,\n" \
"I'm here to get you back online</span>");
	g_object_ref_sink (_tmp44_);
	label1r = _tmp44_;
	_tmp45_ = label1r;
	gtk_label_set_use_markup (_tmp45_, TRUE);
	_tmp46_ = memr;
	_tmp47_ = label1r;
	gtk_box_pack_start (_tmp46_, (GtkWidget*) _tmp47_, TRUE, TRUE, (guint) 50);
	_tmp48_ = memr;
	_tmp49_ = (GtkLabel*) gtk_label_new ("You can use this option to restore your lost files\n" \
"and configurations from any of your backups. Keep in mind\n" \
"restoring your entire system using this tool may take a while,\n" \
"so please be patient and let us get your system back and running");
	g_object_ref_sink (_tmp49_);
	_tmp50_ = _tmp49_;
	gtk_box_pack_start (_tmp48_, (GtkWidget*) _tmp50_, TRUE, FALSE, (guint) 0);
	_g_object_unref0 (_tmp50_);
	_tmp51_ = (GtkButton*) gtk_button_new_with_label ("Restore Memory");
	g_object_ref_sink (_tmp51_);
	button1r = _tmp51_;
	_tmp52_ = button1r;
	_tmp53_ = blue_color;
	gtk_widget_override_background_color ((GtkWidget*) _tmp52_, GTK_STATE_FLAG_NORMAL, &_tmp53_);
	_tmp54_ = (GtkGrid*) gtk_grid_new ();
	g_object_ref_sink (_tmp54_);
	gridfbr = _tmp54_;
	_tmp55_ = gridfbr;
	_tmp56_ = button1r;
	gtk_grid_attach (_tmp55_, (GtkWidget*) _tmp56_, 1, 1, 1, 1);
	_tmp57_ = gridfbr;
	_tmp58_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp58_);
	_tmp59_ = _tmp58_;
	gtk_grid_attach (_tmp57_, (GtkWidget*) _tmp59_, 0, 1, 1, 1);
	_g_object_unref0 (_tmp59_);
	_tmp60_ = gridfbr;
	_tmp61_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp61_);
	_tmp62_ = _tmp61_;
	gtk_grid_attach (_tmp60_, (GtkWidget*) _tmp62_, 2, 1, 1, 1);
	_g_object_unref0 (_tmp62_);
	_tmp63_ = gridfbr;
	gtk_grid_set_column_homogeneous (_tmp63_, TRUE);
	_tmp64_ = gridfbr;
	gtk_grid_set_row_homogeneous (_tmp64_, TRUE);
	_tmp65_ = memr;
	_tmp66_ = gridfbr;
	gtk_box_pack_start (_tmp65_, (GtkWidget*) _tmp66_, TRUE, TRUE, (guint) 60);
	_tmp67_ = _data1_->cr1;
	_tmp68_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp68_);
	_tmp69_ = _tmp68_;
	gtk_box_pack_start (_tmp67_, (GtkWidget*) _tmp69_, FALSE, FALSE, (guint) 100);
	_g_object_unref0 (_tmp69_);
	_tmp70_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp70_);
	cr11 = _tmp70_;
	_tmp71_ = cr11;
	_tmp72_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp72_);
	_tmp73_ = _tmp72_;
	gtk_box_pack_start (_tmp71_, (GtkWidget*) _tmp73_, TRUE, TRUE, (guint) 40);
	_g_object_unref0 (_tmp73_);
	_tmp74_ = (GtkLabel*) gtk_label_new ("<span size='x-large' weight='bold'>Select your backup drive:</span>");
	g_object_ref_sink (_tmp74_);
	cr1label = _tmp74_;
	_tmp75_ = cr1label;
	gtk_label_set_use_markup (_tmp75_, TRUE);
	_tmp76_ = cr11;
	_tmp77_ = cr1label;
	gtk_box_pack_start (_tmp76_, (GtkWidget*) _tmp77_, TRUE, TRUE, (guint) 10);
	_tmp78_ = (GtkFileChooserButton*) gtk_file_chooser_button_new ("Set location", GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER);
	g_object_ref_sink (_tmp78_);
	_data1_->crloc1 = _tmp78_;
	_tmp79_ = cr11;
	_tmp80_ = _data1_->crloc1;
	gtk_box_pack_start (_tmp79_, (GtkWidget*) _tmp80_, TRUE, TRUE, (guint) 0);
	_tmp81_ = cr11;
	_tmp82_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp82_);
	_tmp83_ = _tmp82_;
	gtk_box_pack_start (_tmp81_, (GtkWidget*) _tmp83_, TRUE, TRUE, (guint) 10);
	_g_object_unref0 (_tmp83_);
	_tmp84_ = _data1_->cr1;
	_tmp85_ = cr11;
	gtk_box_pack_start (_tmp84_, (GtkWidget*) _tmp85_, FALSE, FALSE, (guint) 0);
	_tmp86_ = _data1_->cr1;
	_tmp87_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp87_);
	_tmp88_ = _tmp87_;
	gtk_box_pack_start (_tmp86_, (GtkWidget*) _tmp88_, FALSE, FALSE, (guint) 15);
	_g_object_unref0 (_tmp88_);
	_tmp89_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp89_);
	cr12 = _tmp89_;
	_tmp90_ = (GtkButton*) gtk_button_new_with_label ("↩ Go back");
	g_object_ref_sink (_tmp90_);
	crbackbutton = _tmp90_;
	_tmp91_ = crbackbutton;
	g_signal_connect_data (_tmp91_, "clicked", (GCallback) __my_app_window___lambda5__gtk_button_clicked, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp92_ = cr12;
	_tmp93_ = crbackbutton;
	gtk_box_pack_start (_tmp92_, (GtkWidget*) _tmp93_, FALSE, FALSE, (guint) 10);
	_tmp94_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 20);
	g_object_ref_sink (_tmp94_);
	cr15 = _tmp94_;
	_tmp95_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	g_object_ref_sink (_tmp95_);
	ExcludePanel = _tmp95_;
	_tmp96_ = (GtkLabel*) gtk_label_new ("Type Every Folder to be EXCLUDED from the Backup, using ABSOLUTE paths" \
", one per line");
	g_object_ref_sink (_tmp96_);
	ExcludeListLabel = _tmp96_;
	_tmp97_ = (GtkTextView*) gtk_text_view_new ();
	g_object_ref_sink (_tmp97_);
	ExcludeList = _tmp97_;
	_tmp98_ = ExcludeList;
	gtk_text_view_set_editable (_tmp98_, TRUE);
	_tmp99_ = ExcludeList;
	gtk_text_view_set_cursor_visible (_tmp99_, TRUE);
	_tmp100_ = ExcludeList;
	_tmp101_ = _data1_->black_color;
	gtk_widget_override_background_color ((GtkWidget*) _tmp100_, GTK_STATE_FLAG_NORMAL, &_tmp101_);
	_tmp102_ = ExcludePanel;
	gtk_container_set_border_width ((GtkContainer*) _tmp102_, (guint) 10);
	_tmp103_ = ExcludePanel;
	gtk_scrolled_window_set_max_content_height (_tmp103_, 50);
	_tmp104_ = ExcludePanel;
	_tmp105_ = ExcludeList;
	gtk_container_add ((GtkContainer*) _tmp104_, (GtkWidget*) _tmp105_);
	_tmp106_ = cr15;
	_tmp107_ = ExcludeListLabel;
	gtk_box_pack_start (_tmp106_, (GtkWidget*) _tmp107_, TRUE, TRUE, (guint) 0);
	_tmp108_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 20);
	g_object_ref_sink (_tmp108_);
	cr151 = _tmp108_;
	_tmp109_ = cr151;
	_tmp110_ = (GtkLabel*) gtk_label_new (NULL);
	g_object_ref_sink (_tmp110_);
	_tmp111_ = _tmp110_;
	gtk_box_pack_start (_tmp109_, (GtkWidget*) _tmp111_, FALSE, FALSE, (guint) 5);
	_g_object_unref0 (_tmp111_);
	_tmp112_ = cr151;
	_tmp113_ = ExcludePanel;
	gtk_box_pack_start (_tmp112_, (GtkWidget*) _tmp113_, TRUE, TRUE, (guint) 0);
	_tmp114_ = cr151;
	_tmp115_ = (GtkLabel*) gtk_label_new (NULL);
	g_object_ref_sink (_tmp115_);
	_tmp116_ = _tmp115_;
	gtk_box_pack_start (_tmp114_, (GtkWidget*) _tmp116_, FALSE, FALSE, (guint) 5);
	_g_object_unref0 (_tmp116_);
	_tmp117_ = cr15;
	_tmp118_ = cr151;
	gtk_box_pack_start (_tmp117_, (GtkWidget*) _tmp118_, FALSE, FALSE, (guint) 0);
	_tmp119_ = _data1_->cr1;
	_tmp120_ = cr15;
	gtk_box_pack_start (_tmp119_, (GtkWidget*) _tmp120_, FALSE, FALSE, (guint) 0);
	_tmp121_ = (GtkButton*) gtk_button_new_with_label ("✔ Make snapshot");
	g_object_ref_sink (_tmp121_);
	finbutcr = _tmp121_;
	_tmp122_ = finbutcr;
	_tmp123_ = green_color;
	gtk_widget_override_background_color ((GtkWidget*) _tmp122_, GTK_STATE_FLAG_NORMAL, &_tmp123_);
	_tmp124_ = cr12;
	_tmp125_ = finbutcr;
	gtk_box_pack_end (_tmp124_, (GtkWidget*) _tmp125_, FALSE, FALSE, (guint) 10);
	_tmp126_ = finbutcr;
	g_signal_connect_data (_tmp126_, "clicked", (GCallback) __my_app_window___lambda6__gtk_button_clicked, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp127_ = _data1_->cr1;
	_tmp128_ = cr12;
	gtk_box_pack_end (_tmp127_, (GtkWidget*) _tmp128_, FALSE, FALSE, (guint) 10);
	_tmp129_ = _data1_->actualstack;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp129_);
	_tmp130_ = _data1_->actualstack;
	_tmp131_ = my_app_header_bar_new (_tmp130_);
	g_object_ref_sink (_tmp131_);
	headerbar = _tmp131_;
	_tmp132_ = headerbar;
	gtk_window_set_titlebar ((GtkWindow*) self, (GtkWidget*) _tmp132_);
	g_object_set ((GtkWindow*) self, "window-position", GTK_WIN_POS_CENTER, NULL);
	g_object_set ((GtkWindow*) self, "window-position", GTK_WIN_POS_CENTER, NULL);
	gtk_window_set_default_size ((GtkWindow*) self, 800, 600);
	gtk_window_set_resizable ((GtkWindow*) self, FALSE);
	gtk_widget_show_all ((GtkWidget*) self);
	g_print ("Hey, thanks for choosing nostalgia! \n");
	g_print ("If you're looking at the debug output most probably you're having some" \
" trouble with this program, so feel free to contact me and I'll see if" \
" I can help \n");
	g_print ("\n\n");
	g_print ("email: [ioachim.radu@protonmail.com]\n");
	g_print ("webpage: [ioachim.eu.org]\n");
	g_print ("pgp: [C2462D5103FA6059E1E3279C9E9299CD96C65EC6]\n");
	g_print ("\n\n");
	_g_object_unref0 (headerbar);
	_g_object_unref0 (finbutcr);
	_g_object_unref0 (cr151);
	_g_object_unref0 (ExcludeList);
	_g_object_unref0 (ExcludeListLabel);
	_g_object_unref0 (ExcludePanel);
	_g_object_unref0 (cr15);
	_g_object_unref0 (crbackbutton);
	_g_object_unref0 (cr12);
	_g_object_unref0 (cr1label);
	_g_object_unref0 (cr11);
	_g_object_unref0 (gridfbr);
	_g_object_unref0 (button1r);
	_g_object_unref0 (label1r);
	_g_object_unref0 (gridfb);
	_g_object_unref0 (button1);
	_g_object_unref0 (label1);
	_g_object_unref0 (memr);
	_g_object_unref0 (memc);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return obj;
}

static void
my_app_window_class_init (MyAppWindowClass * klass,
                          gpointer klass_data)
{
	my_app_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &MyAppWindow_private_offset);
	G_OBJECT_CLASS (klass)->constructor = my_app_window_constructor;
	G_OBJECT_CLASS (klass)->finalize = my_app_window_finalize;
}

static void
my_app_window_instance_init (MyAppWindow * self,
                             gpointer klass)
{
	self->priv = my_app_window_get_instance_private (self);
}

static void
my_app_window_finalize (GObject * obj)
{
	MyAppWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MY_APP_TYPE_WINDOW, MyAppWindow);
	_g_free0 (self->priv->laoutput);
	G_OBJECT_CLASS (my_app_window_parent_class)->finalize (obj);
}

static GType
my_app_window_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (MyAppWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) my_app_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MyAppWindow), 0, (GInstanceInitFunc) my_app_window_instance_init, NULL };
	GType my_app_window_type_id;
	my_app_window_type_id = g_type_register_static (gtk_application_window_get_type (), "MyAppWindow", &g_define_type_info, 0);
	MyAppWindow_private_offset = g_type_add_instance_private (my_app_window_type_id, sizeof (MyAppWindowPrivate));
	return my_app_window_type_id;
}

GType
my_app_window_get_type (void)
{
	static volatile gsize my_app_window_type_id__once = 0;
	if (g_once_init_enter (&my_app_window_type_id__once)) {
		GType my_app_window_type_id;
		my_app_window_type_id = my_app_window_get_type_once ();
		g_once_init_leave (&my_app_window_type_id__once, my_app_window_type_id);
	}
	return my_app_window_type_id__once;
}

static void
update_label_from_istream_data_free (gpointer _data)
{
	UpdateLabelFromIstreamData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->istream);
	_g_object_unref0 (_data_->label);
	_g_object_unref0 (_data_->ProgBar);
	_g_object_unref0 (_data_->ProgLabel);
	g_slice_free (UpdateLabelFromIstreamData, _data_);
}

void
update_label_from_istream (GInputStream* istream,
                           GtkTextView* label,
                           GtkProgressBar* ProgBar,
                           GtkLabel* ProgLabel,
                           GAsyncReadyCallback _callback_,
                           gpointer _user_data_)
{
	UpdateLabelFromIstreamData* _data_;
	GInputStream* _tmp0_;
	GtkTextView* _tmp1_;
	GtkProgressBar* _tmp2_;
	GtkLabel* _tmp3_;
	g_return_if_fail (istream != NULL);
	g_return_if_fail (label != NULL);
	g_return_if_fail (ProgBar != NULL);
	g_return_if_fail (ProgLabel != NULL);
	_data_ = g_slice_new0 (UpdateLabelFromIstreamData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, update_label_from_istream_data_free);
	_tmp0_ = _g_object_ref0 (istream);
	_g_object_unref0 (_data_->istream);
	_data_->istream = _tmp0_;
	_tmp1_ = _g_object_ref0 (label);
	_g_object_unref0 (_data_->label);
	_data_->label = _tmp1_;
	_tmp2_ = _g_object_ref0 (ProgBar);
	_g_object_unref0 (_data_->ProgBar);
	_data_->ProgBar = _tmp2_;
	_tmp3_ = _g_object_ref0 (ProgLabel);
	_g_object_unref0 (_data_->ProgLabel);
	_data_->ProgLabel = _tmp3_;
	update_label_from_istream_co (_data_);
}

void
update_label_from_istream_finish (GAsyncResult* _res_)
{
	UpdateLabelFromIstreamData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}

static void
update_label_from_istream_ready (GObject* source_object,
                                 GAsyncResult* _res_,
                                 gpointer _user_data_)
{
	UpdateLabelFromIstreamData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	update_label_from_istream_co (_data_);
}

static gchar
string_get (const gchar* self,
            glong index)
{
	gchar _tmp0_;
	gchar result;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = ((gchar*) self)[index];
	result = _tmp0_;
	return result;
}

static glong
string_strnlen (gchar* str,
                glong maxlen)
{
	gchar* end = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	glong result;
	_tmp0_ = memchr (str, 0, (gsize) maxlen);
	end = _tmp0_;
	_tmp1_ = end;
	if (_tmp1_ == NULL) {
		result = maxlen;
		return result;
	} else {
		gchar* _tmp2_;
		_tmp2_ = end;
		result = (glong) (_tmp2_ - str);
		return result;
	}
}

static gchar*
string_substring (const gchar* self,
                  glong offset,
                  glong len)
{
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	gchar* _tmp3_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	if (offset >= ((glong) 0)) {
		_tmp0_ = len >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		string_length = string_strnlen ((gchar*) self, offset + len);
	} else {
		gint _tmp1_;
		gint _tmp2_;
		_tmp1_ = strlen (self);
		_tmp2_ = _tmp1_;
		string_length = (glong) _tmp2_;
	}
	if (offset < ((glong) 0)) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= ((glong) 0), NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < ((glong) 0)) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	_tmp3_ = g_strndup (((gchar*) self) + offset, (gsize) len);
	result = _tmp3_;
	return result;
}

static gchar*
double_to_string (gdouble self)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint _tmp1__length1;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* result;
	_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = G_ASCII_DTOSTR_BUF_SIZE;
	_tmp2_ = g_ascii_dtostr (_tmp1_, (gint) G_ASCII_DTOSTR_BUF_SIZE, self);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp4_;
	return result;
}

static gboolean
update_label_from_istream_co (UpdateLabelFromIstreamData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_tmp0_ = g_data_input_stream_new (_data_->istream);
		_data_->dis = _data_->_tmp0_;
		_data_->_tmp1_ = _data_->dis;
		_data_->_state_ = 1;
		g_data_input_stream_read_line_async (_data_->_tmp1_, G_PRIORITY_DEFAULT, NULL, update_label_from_istream_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp2_ = g_data_input_stream_read_line_finish (_data_->_tmp1_, _data_->_res_, NULL, &_data_->_inner_error0_);
		_data_->line = _data_->_tmp2_;
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			_g_object_unref0 (_data_->dis);
			goto __catch0_g_error;
		}
		while (TRUE) {
			_data_->_tmp3_ = _data_->line;
			if (!(_data_->_tmp3_ != NULL)) {
				break;
			}
			if (timer == 5) {
				_data_->_tmp4_ = gtk_text_view_get_buffer (_data_->label);
				_data_->_tmp5_ = _data_->_tmp4_;
				g_object_set (_data_->_tmp5_, "text", "", NULL);
				timer = 0;
			}
			_data_->_tmp6_ = gtk_text_view_get_buffer (_data_->label);
			_data_->_tmp7_ = _data_->_tmp6_;
			_data_->_tmp8_ = gtk_text_view_get_buffer (_data_->label);
			_data_->_tmp9_ = _data_->_tmp8_;
			g_object_get (_data_->_tmp9_, "text", &_data_->_tmp10_, NULL);
			_data_->_tmp11_ = _data_->_tmp10_;
			_data_->_tmp12_ = _data_->_tmp11_;
			_data_->_tmp13_ = _data_->line;
			_data_->_tmp14_ = g_strconcat (_data_->_tmp13_, "\n", NULL);
			_data_->_tmp15_ = _data_->_tmp14_;
			_data_->_tmp16_ = g_strconcat (_data_->_tmp12_, _data_->_tmp15_, NULL);
			_data_->_tmp17_ = _data_->_tmp16_;
			g_object_set (_data_->_tmp9_, "text", _data_->_tmp17_, NULL);
			_g_free0 (_data_->_tmp17_);
			_g_free0 (_data_->_tmp15_);
			_g_free0 (_data_->_tmp12_);
			_data_->_tmp18_ = _data_->line;
			g_print ("%s", _data_->_tmp18_);
			g_print ("\n");
			_data_->_tmp19_ = _data_->line;
			_data_->_tmp21_ = _data_->_tmp20_ = g_strsplit (_data_->_tmp19_, " ", 0);
			_data_->words = _data_->_tmp21_;
			_data_->words_length1 = _vala_array_length (_data_->_tmp20_);
			_data_->_words_size_ = _data_->words_length1;
			_data_->_tmp22_ = _data_->words;
			_data_->_tmp22__length1 = _data_->words_length1;
			{
				_data_->word_collection_length1 = 0;
				_data_->_word_collection_size_ = 0;
				_data_->word_collection = _data_->_tmp22_;
				_data_->word_collection_length1 = _data_->_tmp22__length1;
				for (_data_->word_it = 0; _data_->word_it < _data_->word_collection_length1; _data_->word_it = _data_->word_it + 1) {
					_data_->word = _data_->word_collection[_data_->word_it];
					{
						_data_->_tmp23_ = _data_->word;
						_data_->_tmp24_ = _data_->word;
						_data_->_tmp25_ = strlen (_data_->_tmp24_);
						_data_->_tmp26_ = _data_->_tmp25_;
						if (string_get (_data_->_tmp23_, (glong) (_data_->_tmp26_ - 1)) == '%') {
							_data_->_tmp27_ = _data_->word;
							_data_->_tmp28_ = _data_->word;
							_data_->_tmp29_ = strlen (_data_->_tmp28_);
							_data_->_tmp30_ = _data_->_tmp29_;
							_data_->_tmp31_ = string_substring (_data_->_tmp27_, (glong) 0, (glong) (_data_->_tmp30_ - 1));
							_data_->word_trimmed = _data_->_tmp31_;
							_data_->_tmp32_ = _data_->word_trimmed;
							_data_->procDone = ((gdouble) StrToInt (_data_->_tmp32_)) / ((gdouble) 100);
							gtk_progress_bar_set_fraction (_data_->ProgBar, _data_->procDone);
							_data_->_tmp33_ = _data_->word_trimmed;
							gtk_progress_bar_set_text (_data_->ProgBar, _data_->_tmp33_);
							_data_->_tmp34_ = _data_->word_trimmed;
							_data_->_tmp35_ = g_strconcat (_data_->_tmp34_, "%", NULL);
							_data_->_tmp36_ = _data_->_tmp35_;
							gtk_label_set_text (_data_->ProgLabel, _data_->_tmp36_);
							_g_free0 (_data_->_tmp36_);
							_data_->_tmp37_ = double_to_string (_data_->procDone);
							_data_->_tmp38_ = _data_->_tmp37_;
							_data_->_tmp39_ = g_strconcat (_data_->_tmp38_, " ", NULL);
							_data_->_tmp40_ = _data_->_tmp39_;
							g_print ("%s", _data_->_tmp40_);
							_g_free0 (_data_->_tmp40_);
							_g_free0 (_data_->_tmp38_);
							_g_free0 (_data_->word_trimmed);
						}
					}
				}
			}
			_data_->_tmp41_ = timer;
			timer = _data_->_tmp41_ + 1;
			_data_->_tmp43_ = _data_->dis;
			_data_->_state_ = 2;
			g_data_input_stream_read_line_async (_data_->_tmp43_, G_PRIORITY_DEFAULT, NULL, update_label_from_istream_ready, _data_);
			return FALSE;
			_state_2:
			_data_->_tmp44_ = g_data_input_stream_read_line_finish (_data_->_tmp43_, _data_->_res_, NULL, &_data_->_inner_error0_);
			_data_->_tmp42_ = _data_->_tmp44_;
			if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
				_data_->words = (_vala_array_free (_data_->words, _data_->words_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (_data_->line);
				_g_object_unref0 (_data_->dis);
				goto __catch0_g_error;
			}
			_data_->_tmp45_ = _data_->_tmp42_;
			_data_->_tmp42_ = NULL;
			_g_free0 (_data_->line);
			_data_->line = _data_->_tmp45_;
			_g_free0 (_data_->_tmp42_);
			_data_->words = (_vala_array_free (_data_->words, _data_->words_length1, (GDestroyNotify) g_free), NULL);
		}
		_g_free0 (_data_->line);
		_g_object_unref0 (_data_->dis);
	}
	goto __finally0;
	__catch0_g_error:
	{
		g_clear_error (&_data_->_inner_error0_);
	}
	__finally0:
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
		g_clear_error (&_data_->_inner_error0_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

gint
StrToInt (const gchar* str)
{
	gint ret = 0;
	gint result;
	g_return_val_if_fail (str != NULL, 0);
	ret = 0;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp2_;
				gint _tmp3_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = strlen (str);
				_tmp3_ = _tmp2_;
				if (!(i < _tmp3_)) {
					break;
				}
				ret *= 10;
				ret += (gint) (string_get (str, (glong) i) - '0');
			}
		}
	}
	result = ret;
	return result;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gssize
_vala_array_length (gpointer array)
{
	gssize length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

